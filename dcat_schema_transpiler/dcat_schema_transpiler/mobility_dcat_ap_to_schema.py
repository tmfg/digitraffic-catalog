from rdflib import Dataset, URIRef, DCAT, DCTERMS, OWL
from typing import List, Dict, Any

from functools import partial

from ckan_schema.mobility_dcat_ap_converter.class_converter import ClassConverter
from ckan_schema.mobility_dcat_ap_converter.classes.dataset import DCATDataset
from ckan_schema.mobility_dcat_ap_converter.classes.distribution import Distribution
from ckan_schema.mobility_dcat_ap_converter.classes.kind import Kind
from ckan_schema.mobility_dcat_ap_converter.classes.license_document import (
    LicenseDocument,
)
from ckan_schema.mobility_dcat_ap_converter.classes.rights_statement import (
    RightsStatement,
)
from dcat_schema_transpiler.namespaces.ADMS import ADMS
from dcat_schema_transpiler.rdfs.rdfs_class import RDFSClass
from dcat_schema_transpiler.namespaces.VCARD import VCARD
from mobility_dcat_ap.namespace import MOBILITYDCATAP


def sort_by_field_name(order_list: List[str], field: Dict[str, Any]):
    try:
        return order_list.index(field["field_name"])
    except:
        return 9999


def sort_by_label(field: Dict[str, Any]):
    return field["label"]


def sort_location(field: Dict[str, Any]):
    return (
        0 if "http://data.europa.eu/nuts/code" in field["value"] else 1,
        field["label"],
    )


def sort_dropdowns(schemas: List[Dict[str, Any]]):
    for schema in schemas:
        if schema.get("preset", "") == "select":
            if schema.get("field_name") == "spatial":
                schema["choices"].sort(key=sort_location)
            else:
                schema["choices"].sort(key=sort_by_label)


def sort_repeating_subfields(schemas: List[Dict[str, Any]]):
    for schema in schemas:
        if schema.get("repeating_subfields") is not None:
            schema["repeating_subfields"].sort(key=sort_by_label)


def sort_dataset_fields(dataset_fields: List[Dict[str, Any]]):
    order = [
        "owner_org",
        "title_translated",
        "name",
        "notes_translated",
        "frequency",
        "mobility_theme",
        "mobility_theme_sub",
        "spatial",
        "version",
        "version_notes_translated",
        "georeferencing_method",
        "contact_point",
        "network_coverage",
        "conforms_to",
        "intended_information_service",
    ]
    dataset_fields.sort(key=partial(sort_by_field_name, order))
    sort_repeating_subfields(dataset_fields)
    sort_dropdowns(dataset_fields)


def sort_resource_fields(resource_fields: List[Dict[str, Any]]):
    order = [
        "url",
        "name_translated",
        "description_translated",
        "format",
        "mobility_data_standard_schema",
        "mobility_data_standard_version",
        "rights_type",
        "license_id",
    ]
    resource_fields.sort(key=partial(sort_by_field_name, order))
    sort_dropdowns(resource_fields)


def resource_fields(ds: Dataset) -> List:
    distribution = RDFSClass.from_ds(DCAT.Distribution, ds)

    ckan_defaults = {DCTERMS.license, DCTERMS.title, DCTERMS.description}

    distribution_fields_to_omit = (
        Distribution.recommended_properties | Distribution.optional_properties
    ) - ckan_defaults

    class_converter = ClassConverter(distribution, ds)
    resource_fields = class_converter.convert(
        {
            DCAT.Distribution: distribution_fields_to_omit,
            DCTERMS.RightsStatement: RightsStatement.recommended_properties,
            DCTERMS.LicenseDocument: LicenseDocument.optional_properties,
        },
        True,
    )

    # append custom field needed to store format iri in ckan
    resource_fields.append(
        {
            "field_name": "format_iri",
            "required": False,
            "form_snippet": None,
            "validators": "set_format_iri",
        }
    )

    sort_resource_fields(resource_fields)

    return resource_fields


def dataset_fields(ds: Dataset) -> List:
    catalog_record = RDFSClass.from_ds(DCAT.CatalogRecord, ds)

    class_converter = ClassConverter(catalog_record, ds)

    omitted_catalog_record_fields = {
        # Generated by CKAN
        DCTERMS.created,
        # Generated by CKAN
        DCTERMS.modified,
        # Should be omitted for now
        DCTERMS.language,
        DCTERMS.publisher,
    }

    omitted_dataset_fields = (
        {
            # Dataset publisher is set to the organization
            DCTERMS.publisher
        }
        | (
            DCATDataset.recommended_properties
            - {
                MOBILITYDCATAP.georeferencingMethod,
                DCAT.contactPoint,
                MOBILITYDCATAP.networkCoverage,
                DCTERMS.conformsTo,
            }
        )
        | (
            DCATDataset.optional_properties
            - {
                OWL.versionInfo,
                ADMS.versionNotes,
                MOBILITYDCATAP.assessmentResult,
                MOBILITYDCATAP.intendedInformationService,
            }
        )
    )

    dataset_fields_schema_map = class_converter.convert(
        {
            DCAT.CatalogRecord: omitted_catalog_record_fields,
            DCAT.Distribution: "all",
            DCAT.Dataset: omitted_dataset_fields,
        },
        True,
    )

    dataset_fields_required_by_ckan = [
        {
            "field_name": "owner_org",
            "label": "Organization",
            "preset": "dataset_organization",
            "required": True,
        },
        {
            "field_name": "name",
            "label": "URL",
            "preset": "dataset_slug",
            "form_placeholder": "eg. my-dataset",
            "required": True,
        },
    ]

    dataset_fields = dataset_fields_required_by_ckan + dataset_fields_schema_map

    sort_dataset_fields(dataset_fields)

    return dataset_fields
